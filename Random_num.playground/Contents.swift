import UIKit
import GameplayKit

// MARK: - generating random numbers without GameplayKit

let int1 = Int.random(in: 0...10)
let int2 = Int.random(in: 0..<10)
let double1 = Double.random(in: 1000...10000)
let float1 = Float.random(in: -100...100)

// Old-fashioned randomness
print(arc4random())
print(arc4random())
// arc4random() generates numbers between 0 and 2^32

// If you want to generate a random number within a specific range there's a better alternative:
print(arc4random() % 6)
// the modulus ensures that the result from arc4random() falls within a specific range (in this case, the range is 0 to 5 inclusive)
// however, this method is not perfect as it produces modulo bias -- it causes some numbers to be generated more frequently than others

// a smarter way of generating random numbers in a range:
print(arc4random_uniform(6))
// this function does not produce modulo bias

// however, what if you want a number between 10 and 20? (Since arc4random_uniform(upperbound:) only has range that starts from 0 upwards)
func RandomInt(min: Int, max: Int) -> Int {
    if max < min { return min }
    return Int(arc4random_uniform(UInt32((max - min) + 1))) + min
}

// MARK: - generating random numbers with GameplayKit: GKRandomSource

print(GKRandomSource.sharedRandom().nextInt())
// this produces a number between -2147483648 and 2147483647

print(GKRandomSource.sharedRandom().nextInt(upperBound: 6))
// this will return a random number from 0 to 5

// there are also nextBool() and nextUniform() -- nextUniform() gives a random floating-point number between 0 and 1

// MARK: - choosing a random number source: GKARC4RandomSource

// Normally we use the system's built-in random number source. However the system's random number generator is not deterministic, which means you can't predict what numbers it will output because it always starts in a different state.
// This means that say someone is playing a 'random-dependent' game involving a dice and the dice roll did not go in their favor, that person can quickly quit the app, relaunch, and try the dice roll again, possibly getting that dice roll he/she wants.

// GameplayKit offers three custom random number sources, all of which are deterministic, and all of which can be serialized -- ie written out to disk using something like NSCoding.
// The three options are: GKLinearCongruentialRandomSource (highest number generation speed but lowest randomness), GKMersenneTwisterRandomSource (lowest number generation speed but highest randomness), GKARC4RandomSource (medium number generation speed and medium randomness)

let arc4 = GKARC4RandomSource()
arc4.nextInt(upperBound: 20)  // generate a random number between 0 and 19

let mersenne = GKMersenneTwisterRandomSource()
mersenne.nextInt(upperBound: 20)

// Note: you should discard the first 769 values generated by ARC4 random number generator before using it for anything important, since it will generate sequences that can be guessed to begin with
arc4.dropValues(1024)

// MARK: - shaping GameplayKit random numbers: GKRandomDistribution, GKShuffledDistribution, GKGaussianDistribution

// random distribution:
let d6 = GKRandomDistribution.d6()
d6.nextInt()

let d20 = GKRandomDistribution.d20()
d20.nextInt()

let crazy = GKRandomDistribution(lowestValue: 1, highestValue: 11539)
crazy.nextInt()
// those are very similar to Int.random(in:), however GameplayKit allows you to create a random distribution OBJECT so that you can re-use it again and again without having to specify the range each time

// When you create a random distribution in this way, iOS automatically creates a random source for you using an unspecified algorithm. If you want one particular random source, there are special constructors for you:
let rand = GKMersenneTwisterRandomSource()
let distribution = GKRandomDistribution(randomSource: rand, lowestValue: 10, highestValue: 20)
print(distribution.nextInt())

// shuffled distribution and gaussian distribution:
// Sometimes you want to manipulate your distribution so that it does not repeat often, or that it leans towards a middle value rather than being truly random.
// Shuffled distribution ensures that sequences repeat less frequently.
// Gaussian distribution ensures that your results naturally form a bell curve where results near to the mean average occur more frequently.

// shuffled distribution:
let shuffled = GKShuffledDistribution.d6()
print(shuffled.nextInt())
print(shuffled.nextInt())
print(shuffled.nextInt())
print(shuffled.nextInt())
print(shuffled.nextInt())
print(shuffled.nextInt())
// above instructions will literally generate the number 1 once, the number 2 once, etc, up to 6 (reduced frequency of repeating sequence)
// however the order would be random

// gaussian distribution:
let gausse = GKGaussianDistribution.d6()
for _ in 0 ..< 10 {
    print(gausse.nextInt())
}

// MARK: - shuffling an array with GameplayKit: arrayByShufflingObjects(in:)

// array shuffling algorithem without GameplayKit:
extension Array {
    mutating func shuffle() {
        for i in 0..<(count - 1) {
            let j = Int(arc4random_uniform(UInt32(count - i))) + 1
            swapAt(i, j)
        }
    }
}
// this method modifies the original array

// array shuffling with GameplayKit:
let lotteryBalls = [Int](1...49)
let shuffledBalls = GKRandomSource.sharedRandom().arrayByShufflingObjects(in: lotteryBalls)  // this method returns a new array
print(shuffledBalls[0])
print(shuffledBalls[1])
print(shuffledBalls[2])
print(shuffledBalls[3])
print(shuffledBalls[4])
print(shuffledBalls[5])

// seeding GameplayKit's random sources:
// When we created our random seeds earlier, we used:
let mersenne2 = GKMersenneTwisterRandomSource()
// this creates a new Mersenne Twister random source with a random starting point

// However if you want to force a starting point, you can create your random source with a specific seed, which is a fixed starting point.
// When you use a seed value, your random number generator becomes predictable -- you can always predict exactly what 'random' numbers get generated.
let fixedLotteryBalls = [Int](1...49)
let fixedShuffledBalls = GKMersenneTwisterRandomSource(seed: 1001).arrayByShufflingObjects(in: fixedLotteryBalls)
print(fixedShuffledBalls[0])
print(fixedShuffledBalls[1])
print(fixedShuffledBalls[2])
print(fixedShuffledBalls[3])
print(fixedShuffledBalls[4])
print(fixedShuffledBalls[5])
// if you run the code now you'll see that the balls are shuffled identically every time. It's a random order, but predictably random.






